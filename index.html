<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>Pokémon Night Sky</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <style>
    html, body {
      margin: 0;
      padding: 0;
      height: 100%;
      background: #080a12;
      color: #eaeaf0;
      font-family: system-ui, -apple-system, Segoe UI, Roboto, sans-serif;
    }
    #app {
      position: fixed;
      inset: 0;
      overflow: hidden;
    }
    .ui {
      position: fixed;
      top: 10px;
      left: 10px;
      background: rgba(10, 12, 20, 0.75);
      border: 1px solid rgba(255, 255, 255, 0.1);
      border-radius: 8px;
      padding: 10px 12px;
      backdrop-filter: blur(4px);
      z-index: 10;
      max-width: 360px;
    }
    .ui h3 {
      margin: 4px 0 8px;
      font-size: 14px;
      opacity: 0.9;
    }
    .row {
      display: flex;
      align-items: center;
      gap: 8px;
      margin: 4px 0;
      font-size: 13px;
    }
    .row label {
      width: 140px;
      opacity: 0.85;
    }
    .row input[type="range"] {
      width: 170px;
    }
    .row input[type="number"] {
      width: 80px;
      background: #0f1220;
      border: 1px solid #2a2d3a;
      color: #eaeaf0;
      border-radius: 6px;
      padding: 4px 6px;
    }
    button {
      background: #2a57ff;
      border: none;
      color: white;
      padding: 6px 10px;
      border-radius: 6px;
      cursor: pointer;
    }
    button:active {
      transform: translateY(1px);
    }
    .hint {
      font-size: 12px;
      opacity: 0.7;
      margin-top: 6px;
    }
  </style>
</head>
<body>
  <div id="app"></div>

  <div class="ui" id="ui">
    <h3>Pokémon Night Sky</h3>
    <div class="row">
      <label>Pokémon count</label>
      <input id="count" type="range" min="0" max="30" value="16" />
      <span id="countV">16</span>
    </div>
    <div class="row">
      <label>FOV (deg)</label>
      <input id="fov" type="range" min="20" max="100" value="55" />
      <span id="fovV">55</span>
    </div>
    <div class="row">
      <label>Sprite opacity</label>
      <input id="opacity" type="range" min="50" max="100" value="88" />
      <span id="opacityV">0.88</span>
    </div>
    <div class="row">
      <label>Glow strength</label>
      <input id="glow" type="range" min="2" max="24" value="12" />
      <span id="glowV">12</span>
    </div>
    <div class="row">
      <label>Random seed</label>
      <input id="seed" type="number" placeholder="None" />
      <button id="randomize">Randomize</button>
    </div>
    <div class="row">
      <button id="recenter">Recenter</button>
      <span class="hint">Drag to pan, wheel/pinch to zoom</span>
    </div>
    <div class="hint">
      Data: HYG (subset), micro-constellations, Pokémon sprites via PokeAPI CDN.
    </div>
  </div>

<script src="https://unpkg.com/pixi.js@7.4.0/dist/pixi.min.js"></script>
<script src="https://unpkg.com/pixi-filters@6.0.5/dist/pixi-filters.min.js"></script>
<script>
  // Now PIXI and PIXI.filters.GlowFilter are available globally
  const app = new PIXI.Application({ resizeTo: document.getElementById("app") });
  document.getElementById("app").appendChild(app.view);

  const glow = new PIXI.filters.GlowFilter({ distance: 12, outerStrength: 2, color: 0xffcc66 });

    // ---------------------------
    // FULL APP LOGIC MERGED HERE
    // ---------------------------

    const DATA = {
      hyg: "data/hyg.min.json",
      asterisms: "data/asterisms.min.json",
      pokemon: "data/pokemon_min.json",
    };

    const TYPE_COLORS = {
      normal: [255, 255, 255],
      fire: [255, 100, 50],
      water: [80, 150, 255],
      electric: [255, 255, 100],
      grass: [100, 255, 100],
      ice: [150, 255, 255],
      fighting: [200, 80, 50],
      poison: [180, 100, 255],
      ground: [210, 180, 100],
      flying: [180, 200, 255],
      psychic: [255, 100, 200],
      bug: [170, 255, 100],
      rock: [200, 180, 140],
      ghost: [150, 100, 200],
      dragon: [100, 150, 255],
      dark: [120, 120, 140],
      steel: [180, 180, 200],
      fairy: [255, 180, 255],
    };

    const app = new PIXI.Application({
      resizeTo: document.getElementById("app"),
      backgroundAlpha: 1,
      backgroundColor: 0x080a12,
      antialias: true,
    });
    document.getElementById("app").appendChild(app.view);

    const scene = new PIXI.Container();
    app.stage.addChild(scene);

    const starLayer = new PIXI.ParticleContainer(120000, {
      position: true,
      scale: true,
      alpha: true,
      tint: false,
    });
    const overlayLayer = new PIXI.Container();
    scene.addChild(starLayer);
    scene.addChild(overlayLayer);

    const infoText = new PIXI.Text("", {
      fontFamily: "ui-monospace, SFMono-Regular, Menlo, monospace",
      fontSize: 13,
      fill: 0xececf2,
      dropShadow: true,
      dropShadowAlpha: 0.35,
      dropShadowDistance: 1,
    });
    infoText.x = 16;
    app.stage.addChild(infoText);

    const starG = new PIXI.Graphics()
      .beginFill(0xffffff)
      .drawCircle(4, 4, 4)
      .endFill();
    const starTexture = app.renderer.generateTexture(starG);

    let HYG = [];
    let AST = [];
    let PKMN = [];

    const state = {
      ra0: Math.random() * 360,
      dec0: Math.random() * 100 - 50,
      fov: 55,
      pokemonCount: 16,
      spriteOpacity: 0.88,
      spriteGlowRadius: 12,
      overlays: [],
      dragging: false,
      dragStart: null,
    };

    function hmsFromDeg(raDeg) {
      const h = raDeg / 15;
      const H = Math.floor(h);
      const M = Math.floor((h - H) * 60);
      const S = ((h - H) * 60 - M) * 60;
      return `${String(H).padStart(2, "0")}h ${String(M).padStart(2, "0")}m ${S.toFixed(1)}s`;
    }
    function dmsFromDeg(decDeg) {
      const sign = decDeg >= 0 ? "+" : "-";
      const d = Math.abs(decDeg);
      const D = Math.floor(d);
      const M = Math.floor((d - D) * 60);
      const S = ((d - D) * 60 - M) * 60;
      return `${sign}${String(D).padStart(2, "0")}° ${String(M).padStart(2, "0")}' ${S.toFixed(1)}"`;
    }

    function gnomonic(raDeg, decDeg, ra0, dec0) {
      const ra = (raDeg * Math.PI) / 180;
      const dec = (decDeg * Math.PI) / 180;
      const RA0 = (ra0 * Math.PI) / 180;
      const DEC0 = (dec0 * Math.PI) / 180;
      const sd = Math.sin(dec);
      const cd = Math.cos(dec);
      const sd0 = Math.sin(DEC0);
      const cd0 = Math.cos(DEC0);
      let dlon = ra - RA0;
      dlon = ((dlon + Math.PI) % (2 * Math.PI)) - Math.PI;
      const denom = sd0 * sd + cd0 * cd * Math.cos(dlon);
      if (denom <= 1e-8) return [NaN, NaN, false];
      const x = (cd * Math.sin(dlon)) / denom;
      const y = (cd0 * sd - sd0 * cd * Math.cos(dlon)) / denom;
      return [x, y, true];
    }

    function updateInfo(starCount) {
      const lines = [
        `Center RA: ${hmsFromDeg(state.ra0)}`,
        `Center Dec: ${dmsFromDeg(state.dec0)}`,
        `FOV: ${state.fov.toFixed(1)}°`,
        `Stars drawn: ${starCount}`,
        `Pokémon overlays: ${state.overlays.length}`,
        `Time: ${new Date().toUTCString()}`,
      ];
      infoText.text = lines.join("\n");
      infoText.y = app.renderer.height - 20 - infoText.height;
    }

    Promise.all([
      fetch(DATA.hyg).then((r) => r.json()),
      fetch(DATA.asterisms).then((r) => r.json()),
      fetch(DATA.pokemon).then((r) => r.json()),
    ]).then(([hyg, ast, pkmn]) => {
      HYG = hyg;
      AST = ast;
      PKMN = pkmn;
      drawStars();
      spawnOverlays(true);
      app.ticker.add(tick);
    });

    function drawStars() {
      starLayer.removeChildren();
      const W = app.renderer.width;
      const H = app.renderer.height;
      const halfW = Math.tan((state.fov * Math.PI) / 180 / 2);
      const halfH = Math.atan(Math.tan((state.fov * Math.PI) / 180 / 2) * (H / W));
      const halfHtan = Math.tan(halfH);
      const starsToDraw = [];
      for (let s of HYG) {
        const [x, y, ok] = gnomonic(s.ra_deg, s.dec_deg, state.ra0, state.dec0);
        if (!ok) continue;
        if (Math.abs(x) > halfW || Math.abs(y) > halfHtan) continue;
        const px = ((x / halfW) + 1) * 0.5 * W;
        const py = ((-y / halfHtan) + 1) * 0.5 * H;
        const mag = s.mag;
        const r = Math.max(0.6, Math.min(2.5, 3.0 - 0.5 * (mag - 1.0)));
        const a = Math.max(0.15, Math.min(0.85, 1.1 - (mag + 1) * 0.12));
        starsToDraw.push({ px, py, r, a });
      }
      updateInfo(starsToDraw.length);
      for (let st of starsToDraw) {
        const spr = new PIXI.Sprite(starTexture);
        spr.x = st.px;
        spr.y = st.py;
        spr.anchor.set(0.5);
        spr.alpha = st.a;
        const s = (st.r * 2) / 8;
        spr.scale.set(s, s);
        starLayer.addChild(spr);
      }
    }

    function pickAsterismsInView(limit) {
      const W = app.renderer.width;
      const H = app.renderer.height;
      const halfW = Math.tan((state.fov * Math.PI) / 180 / 2);
      const halfH = Math.atan(Math.tan((state.fov * Math.PI) / 180 / 2) * (H / W));
      const halfHtan = Math.tan(halfH);
      const picks = [];
      for (let r of AST) {
        const [x, y, ok] = gnomonic(r.ra_deg_center, r.dec_deg_center, state.ra0, state.dec0);
        if (!ok) continue;
        if (Math.abs(x) > halfW || Math.abs(y) > halfHtan) continue;
        const px = ((x / halfW) + 1) * 0.5 * W;
        const py = ((-y / halfHtan) + 1) * 0.5 * H;
        picks.push({ rec: r, px, py });
      }
      return picks.sort(() => Math.random() - 0.5).slice(0, limit);
    }

    function pickRandomPokemon(n) {
      return Array.from({ length: n }, () => PKMN[Math.floor(Math.random() * PKMN.length)]);
    }

    async function buildOverlay(pick, info, size) {
      const sprite = await PIXI.Assets.load(info.sprite);
      const cont = new PIXI.Container();
      cont.x = pick.px;
      cont.y = pick.py;
      cont.alpha = 0.0;
      const spr = new PIXI.Sprite(sprite);
      spr.anchor.set(0.5);
      const scale = size / Math.max(sprite.width, sprite.height);
      spr.scale.set(scale);
      spr.alpha = state.spriteOpacity;
      const pType = (info.types && info.types[0]) || "normal";
      const glowRGB = TYPE_COLORS[pType] || [255, 223, 128];
      const glow = new GlowFilter({
        distance: state.spriteGlowRadius,
        outerStrength: 2,
        innerStrength: 0,
        color: (glowRGB[0] << 16) + (glowRGB[1] << 8) + glowRGB[2],
        quality: 0.5,
      });
      spr.filters = [glow];
      cont.addChild(spr);
      cont._meta = { spr, glow, targetAlpha: 1.0 };
      return cont;
    }

    async function spawnOverlays(clearFirst) {
      if (clearFirst) {
        overlayLayer.removeChildren();
        state.overlays = [];
      }
      const picks = pickAsterismsInView(state.pokemonCount);
      const pokes = pickRandomPokemon(picks.length);
      for (let i = 0; i < picks.length; i++) {
        const size = 180 + Math.random() * 80;
        const cont = await buildOverlay(picks[i], pokes[i], size);
        overlayLayer.addChild(cont);
        state.overlays.push(cont);
      }
    }

    function tick(dt) {
      for (let c of state.overlays) {
        c.alpha += (c._meta.targetAlpha - c.alpha) * 0.08 * dt;
        c._meta.spr.alpha = state.spriteOpacity;
        c._meta.glow.distance = state.spriteGlowRadius;
      }
    }

    // Simple mouse pan/zoom
    app.view.addEventListener("mousedown", (e) => {
      state.dragging = true;
      state.dragStart = { x: e.clientX, y: e.clientY, ra0: state.ra0, dec0: state.dec0 };
    });
    app.view.addEventListener("mousemove", (e) => {
      if (!state.dragging) return;
      const dx = e.clientX - state.dragStart.x;
      const dy = e.clientY - state.dragStart.y;
      const W = app.renderer.width;
      const H = app.renderer.height;
      const rw = Math.tan((state.fov * Math.PI) / 180 / 2);
      const rh = Math.atan(Math.tan((state.fov * Math.PI) / 180 / 2) * (H / W));
      const scaleX = (2 * rw) / W;
      const scaleY = (2 * Math.tan(rh)) / H;
      state.ra0 = (state.dragStart.ra0 - (dx * scaleX * 180) / Math.PI + 360) % 360;
      state.dec0 = Math.max(-89, Math.min(89, state.dragStart.dec0 + (dy * scaleY * 180) / Math.PI));
      drawStars();
    });
    window.addEventListener("mouseup", () => { state.dragging = false; });
    app.view.addEventListener("wheel", (e) => {
      e.preventDefault();
      const delta = Math.sign(e.deltaY);
      state.fov = Math.max(20, Math.min(100, state.fov + delta * 3));
      drawStars();
    });
  </script>
</body>
</html>
